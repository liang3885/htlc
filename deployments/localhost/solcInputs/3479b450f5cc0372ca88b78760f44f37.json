{
  "language": "Solidity",
  "sources": {
    "contracts/HTLC.sol": {
      "content": "// SPDX-License-IDentifier: MIT\npragma solidity ^0.8.18;\n\n/**\n * This contract implements hashed timelock function for ETH swap on different EVM based chain;\n */\ncontract HTLC {\n\n    event NewTransaction(\n        bytes32 indexed txID,\n        address indexed sender,\n        address indexed receiver,\n        uint amount,\n        bytes32 hashlock,\n        uint timelock\n    );\n    event Withdraw(bytes32 indexed txID);\n    event Refund(bytes32 indexed txID);\n\n    struct LockedTransaction {\n        address payable sender;\n        address payable receiver;\n        uint256 amount;\n        bytes32 hashlock;\n        bytes32 preimage;\n        uint32 timelock; // UNIX timestamp seconds - locked UNTIL this time\n        bool withdrawn;\n        bool refunded;\n    }\n\n    modifier txExists(bytes32 txID) {\n        require(transactionExists(txID), \"txID does not exist\");\n        _;\n    }\n    modifier hashlockValid(bytes32 txID, bytes32 preImage) {\n        require(\n            transactions[txID].hashlock == sha256(abi.encodePacked(preImage)),\n            \"hashlock hash does not match\"\n        );\n        _;\n    }\n    modifier withdrawable(bytes32 txID) {\n        require(transactions[txID].receiver == msg.sender, \"only receiver can withdraw\");\n        require(transactions[txID].withdrawn == false, \"tx is already withdrawn\");\n        require(transactions[txID].timelock > block.timestamp, \"timelock is expired\");\n        _;\n    }\n    modifier refundable(bytes32 txID) {\n        require(transactions[txID].sender == msg.sender, \"only sender can refund\");\n        require(transactions[txID].refunded == false, \"tx is already refunded\");\n        require(transactions[txID].withdrawn == false, \"tx is already withdrawn\");\n        require(transactions[txID].timelock <= block.timestamp, \"timelock not passed yet\");\n        _;\n    }\n\n    mapping (bytes32 => LockedTransaction) transactions;\n    mapping (address => bytes32[]) txIds;\n\n\n    /**\n     * @notice make a new hashed timelock transaction by _hashlock, used by not knowing the preImage\n     * \n     * @param _receiver Receiver of the ETH.\n     * @param _hashlock hashlock\n     * @param _timelock UNIX epoch seconds time that the lock expires at.\n     * \n     * @return txID of the new hashed time lock transaction. This is needed for subsequent\n     *                    calls.\n     */\n    function newTransactionByHashLock(address payable _receiver, bytes32 _hashlock, uint32 _timelock)\n        external\n        payable\n        returns (bytes32 txID)\n    {\n        require(msg.value > 0, \"transfer amount must be greater than 0\");\n        require(_timelock > block.timestamp, \"timelock must be in the future\");\n        txID = _newTransaction(msg.sender, _receiver, _hashlock, _timelock);\n        txIds[msg.sender].push(txID);\n    }\n\n    function getLastTxId() external view returns(bytes32){\n        bytes32[] memory ids = txIds[msg.sender];\n        return ids[ids.length -1];\n    }\n\n\n    function _newTransaction(address _sender, address _receiver, \n    bytes32 _hashlock, uint32 _timelock)\n        internal\n        returns (bytes32 txID) \n    {\n        txID = sha256(\n            abi.encodePacked(\n                _sender,\n                _receiver,\n                msg.value,\n                _hashlock,\n                _timelock\n            )\n        );\n\n        // Reject if a contract already exists with the same parameters. The\n        // sender must change one of these parameters to create a new distinct\n        // contract.\n        if (transactionExists(txID))\n            revert(\"transaction already exists\");\n\n        transactions[txID] = LockedTransaction(\n            payable(_sender),\n            payable(_receiver),\n            msg.value,\n            _hashlock,\n            0x0,\n            _timelock,\n            false,\n            false\n        );\n\n\n        emit NewTransaction(\n            txID,\n            _sender,\n            _receiver,\n            msg.value,\n            _hashlock,\n            _timelock\n        );\n    }\n\n    /**\n     * @notice once know the preimage of the hashlock, receiver can call this function\n     * to extract the locked token\n     *\n     * @param _txID hashed lock transaction ID.\n     * @param _preimage sha256(_preimage) should equal the contract hashlock.\n     * @return bool true on success\n     */\n    function withdraw(bytes32 _txID, bytes32 _preimage)\n        external\n        txExists(_txID)\n        hashlockValid(_txID, _preimage)\n        withdrawable(_txID)\n        returns (bool)\n    {\n        LockedTransaction storage c = transactions[_txID];\n        c.preimage = _preimage;\n        c.withdrawn = true;\n        c.receiver.transfer(c.amount);\n        emit Withdraw(_txID);\n        return true;\n    }\n\n    /**\n     * @notice when timelock has expired, sender can call this function to retrieve \n     * their locked token.\n     *\n     * @param _txID hashed lock transaction ID.\n     * @return bool true on success\n     */\n    function refund(bytes32 _txID)\n        external\n        txExists(_txID)\n        refundable(_txID)\n        returns (bool)\n    {\n        LockedTransaction storage c = transactions[_txID];\n        c.refunded = true;\n        c.sender.transfer(c.amount);\n        emit Refund(_txID);\n        return true;\n    }\n\n    /**\n     * @dev Get transaction details by txID.\n     * @param _txID  transaction ID\n     */\n    function getTransaction(bytes32 _txID)\n        public\n        view\n        returns (\n            address sender,\n            address receiver,\n            uint amount,\n            bytes32 hashlock,\n            uint timelock,\n            bool withdrawn,\n            bool refunded,\n            bytes32 preimage\n        )\n    {\n        if (transactionExists(_txID) == false)\n            return (address(0), address(0), 0, 0, 0, false, false, 0);\n        LockedTransaction storage c = transactions[_txID];\n        return (\n            c.sender,\n            c.receiver,\n            c.amount,\n            c.hashlock,\n            c.timelock,\n            c.withdrawn,\n            c.refunded,\n            c.preimage\n        );\n    }\n\n    /**\n     * @dev Is there a contract with id _txID.\n     * @param _txID ID into contracts mapping.\n     */\n    function transactionExists(bytes32 _txID)\n        internal\n        view\n        returns (bool exists)\n    {\n        exists = (transactions[_txID].sender != address(0));\n    }\n\n}\n\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}